              return data.valueFields.current;\n            },\n            aboveAxis: function (point) {\n                var value = point.value.current;\n                return value > 0;\n            },\n            createAnimation: function () {\n                var points = this.points;\n                var point;\n                this._setAnimationOptions();\n                for (var idx = 0; idx < points.length; idx++) {\n                    point = points[idx];\n                    point.options.animation = this.options.animation;\n                    point.createAnimation();\n                }\n            },\n            _setAnimationOptions: BarChart.fn._setAnimationOptions\n        });\n        var Bullet = ChartElement.extend({\n            init: function (value, options) {\n                var bullet = this;\n                ChartElement.fn.init.call(bullet, options);\n                bullet.aboveAxis = bullet.options.aboveAxis;\n                bullet.color = options.color || WHITE;\n                bullet.value = value;\n            },\n            options: {\n                border: { width: 1 },\n                vertical: false,\n                opacity: 1,\n                target: {\n                    shape: '',\n                    border: {\n                        width: 0,\n                        color: 'green'\n                    },\n                    line: { width: 2 }\n                },\n                tooltip: { format: 'Current: {0}</br>Target: {1}' }\n            },\n            render: function () {\n                var bullet = this, options = bullet.options;\n                if (!bullet._rendered) {\n                    bullet._rendered = true;\n                    if (defined(bullet.value.target)) {\n                        bullet.target = new Target({\n                            type: options.target.shape,\n                            background: options.target.color || bullet.color,\n                            opacity: options.opacity,\n                            zIndex: options.zIndex,\n                            border: options.target.border,\n                            vAlign: TOP,\n                            align: RIGHT\n                        });\n                        bullet.append(bullet.target);\n                    }\n                    bullet.createNote();\n                }\n            },\n            reflow: function (box) {\n                this.render();\n                var bullet = this, options = bullet.options, chart = bullet.owner, target = bullet.target, invertAxes = options.invertAxes, valueAxis = chart.seriesValueAxis(bullet.options), categorySlot = chart.categorySlot(chart.categoryAxis, options.categoryIx, valueAxis), targetValueSlot = valueAxis.getSlot(bullet.value.target), targetSlotX = invertAxes ? targetValueSlot : categorySlot, targetSlotY = invertAxes ? categorySlot : targetValueSlot, targetSlot;\n                if (target) {\n                    targetSlot = new Box2D(targetSlotX.x1, targetSlotY.y1, targetSlotX.x2, targetSlotY.y2);\n                    target.options.height = invertAxes ? targetSlot.height() : options.target.line.width;\n                    target.options.width = invertAxes ? options.target.line.width : targetSlot.width();\n                    target.reflow(targetSlot);\n                }\n                if (bullet.note) {\n                    bullet.note.reflow(box);\n                }\n                bullet.box = box;\n            },\n            createVisual: function () {\n                ChartElement.fn.createVisual.call(this);\n                var options = this.options;\n                var body = draw.Path.fromRect(this.box.toRect(), {\n                    fill: {\n                        color: this.color,\n                        opacity: options.opacity\n                    },\n                    stroke: null\n                });\n                if (options.border.width > 0) {\n                    body.options.set('stroke', {\n                        color: options.border.color || this.color,\n                        width: options.border.width,\n                        dashType: options.border.dashType,\n                        opacity: valueOrDefault(options.border.opacity, options.opacity)\n                    });\n                }\n                this.bodyVisual = body;\n                alignPathToPixel(body);\n                this.visual.append(body);\n            },\n            createAnimation: function () {\n                if (this.bodyVisual) {\n                    this.animation = draw.Animation.create(this.bodyVisual, this.options.animation);\n                }\n            },\n            tooltipAnchor: function (tooltipWidth, tooltipHeight) {\n                var bar = this, options = bar.options, box = bar.box, vertical = options.vertical, aboveAxis = bar.aboveAxis, clipBox = bar.owner.pane.clipBox() || box, x, y;\n                if (vertical) {\n                    x = box.x2 + TOOLTIP_OFFSET;\n                    y = aboveAxis ? math.max(box.y1, clipBox.y1) : math.min(box.y2, clipBox.y2) - tooltipHeight;\n                } else {\n                    var x1 = math.max(box.x1, clipBox.x1), x2 = math.min(box.x2, clipBox.x2);\n                    if (options.isStacked) {\n                        x = aboveAxis ? x2 - tooltipWidth : x1;\n                        y = box.y1 - tooltipHeight - TOOLTIP_OFFSET;\n                    } else {\n                        x = aboveAxis ? x2 + TOOLTIP_OFFSET : x1 - tooltipWidth - TOOLTIP_OFFSET;\n                        y = box.y1;\n                    }\n                }\n                return new Point2D(x, y);\n            },\n            createHighlight: function (style) {\n                return draw.Path.fromRect(this.box.toRect(), style);\n            },\n            highlightVisual: function () {\n                return this.bodyVisual;\n            },\n            highlightVisualArgs: function () {\n                return {\n                    rect: this.box.toRect(),\n                    visual: this.bodyVisual,\n                    options: this.options\n                };\n            },\n            formatValue: function (format) {\n                var bullet = this;\n                return bullet.owner.formatPointValue(bullet, format);\n            }\n        });\n        deepExtend(Bullet.fn, PointEventsMixin);\n        deepExtend(Bullet.fn, NoteMixin);\n        var Target = ShapeElement.extend();\n        deepExtend(Target.fn, PointEventsMixin);\n        var ErrorBarBase = ChartElement.extend({\n            init: function (low, high, isVertical, chart, series, options) {\n                var errorBar = this;\n                errorBar.low = low;\n                errorBar.high = high;\n                errorBar.isVertical = isVertical;\n                errorBar.chart = chart;\n                errorBar.series = series;\n                ChartElement.fn.init.call(errorBar, options);\n            },\n            options: {\n                animation: {\n                    type: FADEIN,\n                    delay: INITIAL_ANIMATION_DURATION\n                },\n                endCaps: true,\n                line: { width: 1 },\n                zIndex: 1\n            },\n            getAxis: function () {\n            },\n            reflow: function (targetBox) {\n                var linePoints, errorBar = this, endCaps = errorBar.options.endCaps, isVertical = errorBar.isVertical, axis = errorBar.getAxis(), valueBox = axis.getSlot(errorBar.low, errorBar.high), centerBox = targetBox.center(), capsWidth = errorBar.getCapsWidth(targetBox, isVertical), capValue = isVertical ? centerBox.x : centerBox.y, capStart = capValue - capsWidth, capEnd = capValue + capsWidth;\n                if (isVertical) {\n                    linePoints = [\n                        Point2D(centerBox.x, valueBox.y1),\n                        Point2D(centerBox.x, valueBox.y2)\n                    ];\n                    if (endCaps) {\n                        linePoints.push(Point2D(capStart, valueBox.y1), Point2D(capEnd, valueBox.y1), Point2D(capStart, valueBox.y2), Point2D(capEnd, valueBox.y2));\n                    }\n                    errorBar.box = Box2D(capStart, valueBox.y1, capEnd, valueBox.y2);\n                } else {\n                    linePoints = [\n                        Point2D(valueBox.x1, centerBox.y),\n                        Point2D(valueBox.x2, centerBox.y)\n                    ];\n                    if (endCaps) {\n                        linePoints.push(Point2D(valueBox.x1, capStart), Point2D(valueBox.x1, capEnd), Point2D(valueBox.x2, capStart), Point2D(valueBox.x2, capEnd));\n                    }\n                    errorBar.box = Box2D(valueBox.x1, capStart, valueBox.x2, capEnd);\n                }\n                errorBar.linePoints = linePoints;\n            },\n            getCapsWidth: function (box, isVertical) {\n                var boxSize = isVertical ? box.width() : box.height(), capsWidth = math.min(math.floor(boxSize / 2), DEFAULT_ERROR_BAR_WIDTH) || DEFAULT_ERROR_BAR_WIDTH;\n                return capsWidth;\n            },\n            createVisual: function () {\n                var that = this;\n                var options = that.options;\n                var visual = options.visual;\n                if (visual) {\n                    that.visual = visual({\n                        low: that.low,\n                        high: that.high,\n                        rect: that.box.toRect(),\n                        sender: that.getChart(),\n                        options: {\n                            endCaps: options.endCaps,\n                            color: options.color,\n                            line: options.line\n                        },\n                        createVisual: function () {\n                            that.createDefaultVisual();\n                            var defaultVisual = that.visual;\n                            delete that.visual;\n                            return defaultVisual;\n                        }\n                    });\n                } else {\n                    that.createDefaultVisual();\n                }\n            },\n            createDefaultVisual: function () {\n                var errorBar = this, options = errorBar.options, lineOptions = {\n                        stroke: {\n                            color: options.color,\n                            width: options.line.width,\n                            dashType: options.line.dashType\n                        }\n                    }, linePoints = errorBar.linePoints;\n                ChartElement.fn.createVisual.call(this);\n                for (var idx = 0; idx < linePoints.length; idx += 2) {\n                    var line = new draw.Path(lineOptions).moveTo(linePoints[idx].x, linePoints[idx].y).lineTo(linePoints[idx + 1].x, linePoints[idx + 1].y);\n                    this.visual.append(line);\n                }\n            }\n        });\n        var CategoricalErrorBar = ErrorBarBase.extend({\n            getAxis: function () {\n                var errorBar = this, chart = errorBar.chart, series = errorBar.series, axis = chart.seriesValueAxis(series);\n                return axis;\n            }\n        });\n        var ScatterErrorBar = ErrorBarBase.extend({\n            getAxis: function () {\n                var errorBar = this, chart = errorBar.chart, series = errorBar.series, axes = chart.seriesAxes(series), axis = errorBar.isVertical ? axes.y : axes.x;\n                return axis;\n            }\n        });\n        var LinePoint = ChartElement.extend({\n            init: function (value, options) {\n                var point = this;\n                ChartElement.fn.init.call(point);\n                point.value = value;\n                point.options = options;\n                point.aboveAxis = valueOrDefault(point.options.aboveAxis, true);\n                point.tooltipTracking = true;\n            },\n            defaults: {\n                vertical: true,\n                markers: {\n                    visible: true,\n                    background: WHITE,\n                    size: LINE_MARKER_SIZE,\n                    type: CIRCLE,\n                    border: { width: 2 },\n                    opacity: 1\n                },\n                labels: {\n                    visible: false,\n                    position: ABOVE,\n                    margin: getSpacing(3),\n                    padding: getSpacing(4),\n                    animation: {\n                        type: FADEIN,\n                        delay: INITIAL_ANIMATION_DURATION\n                    }\n                },\n                notes: { label: {} },\n                highlight: { markers: { border: {} } }\n            },\n            render: function () {\n                var point = this, options = point.options, markers = options.markers, labels = options.labels, labelText = point.value;\n                if (point._rendered) {\n                    return;\n                } else {\n                    point._rendered = true;\n                }\n                if (markers.visible && markers.size) {\n                    point.marker = point.createMarker();\n                    point.append(point.marker);\n                }\n                if (labels.visible) {\n                    if (labels.template) {\n                        var labelTemplate = template(labels.template);\n                        labelText = labelTemplate({\n                            dataItem: point.dataItem,\n                            category: point.category,\n                            value: point.value,\n                            percentage: point.percentage,\n                            series: point.series\n                        });\n                    } else if (labels.format) {\n                        labelText = point.formatValue(labels.format);\n                    }\n                    point.label = new TextBox(labelText, deepExtend({\n                        align: CENTER,\n                        vAlign: CENTER,\n                        margin: {\n                            left: 5,\n                            right: 5\n                        },\n                        zIndex: valueOrDefault(labels.zIndex, this.series.zIndex)\n                    }, labels));\n                    point.append(point.label);\n                }\n                point.createNote();\n                if (point.errorBar) {\n                    point.append(point.errorBar);\n                }\n            },\n            markerBorder: function () {\n                var options = this.options.markers;\n                var background = options.background;\n                var border = deepExtend({ color: this.color }, options.border);\n                if (!defined(border.color)) {\n                    border.color = new Color(background).brightness(BAR_BORDER_BRIGHTNESS).toHex();\n                }\n                return border;\n            },\n            createVisual: noop,\n            createMarker: function () {\n                var options = this.options.markers;\n                var marker = new ShapeElement({\n                    type: options.type,\n                    width: options.size,\n                    height: options.size,\n                    rotation: options.rotation,\n                    background: options.background,\n                    border: this.markerBorder(),\n                    opacity: options.opacity,\n                    zIndex: valueOrDefault(options.zIndex, this.series.zIndex),\n                    animation: options.animation,\n                    visual: options.visual\n                }, {\n                    dataItem: this.dataItem,\n                    value: this.value,\n                    series: this.series,\n                    category: this.category\n                });\n                return marker;\n            },\n            markerBox: function () {\n                if (!this.marker) {\n                    this.marker = this.createMarker();\n                    this.marker.reflow(this._childBox);\n                }\n                return this.marker.box;\n            },\n            reflow: function (targetBox) {\n                var point = this, options = point.options, vertical = options.vertical, aboveAxis = point.aboveAxis, childBox, center;\n                point.render();\n                point.box = targetBox;\n                childBox = targetBox.clone();\n                if (vertical) {\n                    if (aboveAxis) {\n                        childBox.y1 -= childBox.height();\n                    } else {\n                        childBox.y2 += childBox.height();\n                    }\n                } else {\n                    if (aboveAxis) {\n                        childBox.x1 += childBox.width();\n                    } else {\n                        childBox.x2 -= childBox.width();\n                    }\n                }\n                point._childBox = childBox;\n                if (point.marker) {\n                    point.marker.reflow(childBox);\n                }\n                point.reflowLabel(childBox);\n                if (point.errorBars) {\n                    for (var i = 0; i < point.errorBars.length; i++) {\n                        point.errorBars[i].reflow(childBox);\n                    }\n                }\n                if (point.note) {\n                    var noteTargetBox = point.markerBox();\n                    if (!point.marker) {\n                        center = noteTargetBox.center();\n                        noteTargetBox = Box2D(center.x, center.y, center.x, center.y);\n                    }\n                    point.note.reflow(noteTargetBox);\n                }\n            },\n            reflowLabel: function (box) {\n                var point = this, options = point.options, label = point.label, anchor = options.labels.position;\n                if (label) {\n                    anchor = anchor === ABOVE ? TOP : anchor;\n                    anchor = anchor === BELOW ? BOTTOM : anchor;\n                    label.reflow(box);\n                    label.box.alignTo(point.markerBox(), anchor);\n                    label.reflow(label.box);\n                }\n            },\n            createHighlight: function () {\n                var highlight = this.options.highlight;\n                var markers = highlight.markers;\n                var defaultColor = this.markerBorder().color;\n                var options = this.options.markers;\n                var shadow = new ShapeElement({\n                    type: options.type,\n                    width: options.size,\n                    height: options.size,\n                    rotation: options.rotation,\n                    background: markers.color || defaultColor,\n                    border: {\n                        color: markers.border.color,\n                        width: markers.border.width,\n                        opacity: valueOrDefault(markers.border.opacity, 1)\n                    },\n                    opacity: valueOrDefault(markers.opacity, 1)\n                });\n                shadow.reflow(this._childBox);\n                return shadow.getElement();\n            },\n            highlightVisual: function () {\n                return (this.marker || {}).visual;\n            },\n            highlightVisualArgs: function () {\n                var marker = this.marker;\n                var visual;\n                var rect;\n                if (marker) {\n                    rect = marker.paddingBox.toRect();\n                    visual = marker.visual;\n                } else {\n                    var size = this.options.markers.size;\n                    var halfSize = size / 2;\n                    var center = this.box.center();\n                    rect = new geom.Rect([\n                        center.x - halfSize,\n                        center.y - halfSize\n                    ], [\n                        size,\n                        size\n                    ]);\n                }\n                return {\n                    options: this.options,\n                    rect: rect,\n                    visual: visual\n                };\n            },\n            tooltipAnchor: function (tooltipWidth, tooltipHeight) {\n                var point = this, markerBox = point.markerBox(), aboveAxis = point.aboveAxis, x = markerBox.x2 + TOOLTIP_OFFSET, y = aboveAxis ? markerBox.y1 - tooltipHeight : markerBox.y2, clipBox = point.owner.pane.clipBox(), showTooltip = !clipBox || clipBox.overlaps(markerBox);\n                if (showTooltip) {\n                    return Point2D(x, y);\n                }\n            },\n            formatValue: function (format) {\n                var point = this;\n                return point.owner.formatPointValue(point, format);\n            },\n            overlapsBox: function (box) {\n                var markerBox = this.markerBox();\n                return markerBox.overlaps(box);\n            }\n        });\n        deepExtend(LinePoint.fn, PointEventsMixin);\n        deepExtend(LinePoint.fn, NoteMixin);\n        var Bubble = LinePoint.extend({\n            init: function (value, options) {\n                var point = this;\n                LinePoint.fn.init.call(point, value, options);\n                point.category = value.category;\n            },\n            defaults: {\n                labels: { position: CENTER },\n                highlight: {\n                    opacity: 1,\n                    border: {\n                        width: 1,\n                        opacity: 1\n                    }\n                }\n            },\n            createHighlight: function () {\n                var highlight = this.options.highlight;\n                var border = highlight.border;\n                var markers = this.options.markers;\n                var center = this.box.center();\n                var radius = markers.size / 2 - border.width / 2;\n                var overlay = new draw.Circle(new geom.Circle([\n                    center.x,\n                    center.y\n                ], radius), {\n                    stroke: {\n                        color: border.color || new Color(markers.background).brightness(BAR_BORDER_BRIGHTNESS).toHex(),\n                        width: border.width,\n                        opacity: border.opacity\n                    },\n                    fill: {\n                        color: markers.background,\n                        opacity: highlight.opacity\n                    }\n                });\n                return overlay;\n            }\n        });\n        var LineSegment = ChartElement.extend({\n            init: function (linePoints, series, seriesIx) {\n                var segment = this;\n                ChartElement.fn.init.call(segment);\n                segment.linePoints = linePoints;\n                segment.series = series;\n                segment.seriesIx = seriesIx;\n            },\n            options: { closed: false },\n            points: function (visualPoints) {\n                var segment = this, linePoints = segment.linePoints.concat(visualPoints || []), points = [];\n                for (var i = 0, length = linePoints.length; i < length; i++) {\n                    if (linePoints[i].visible !== false) {\n                        points.push(linePoints[i]._childBox.toRect().center());\n                    }\n                }\n                return points;\n            },\n            createVisual: function () {\n                var options = this.options;\n                var series = this.series;\n                var defaults = series._defaults;\n                var color = series.color;\n                if (isFn(color) && defaults) {\n                    color = defaults.color;\n                }\n                var line = draw.Path.fromPoints(this.points(), {\n                    stroke: {\n                        color: color,\n                        width: series.width,\n                        opacity: series.opacity,\n                        dashType: series.dashType\n                    },\n                    zIndex: series.zIndex\n                });\n                if (options.closed) {\n                    line.close();\n                }\n                this.visual = line;\n            },\n            aliasFor: function (e, coords) {\n                var segment = this, seriesIx = segment.seriesIx;\n                return segment.parent.getNearestPoint(coords.x, coords.y, seriesIx);\n            }\n        });\n        var LineChartMixin = {\n            renderSegments: function () {\n                var chart = this, options = chart.options, series = options.series, seriesPoints = chart.seriesPoints, currentSeries, seriesIx, seriesCount = seriesPoints.length, sortedPoints, linePoints, point, pointIx, pointCount, lastSegment;\n                this._segments = [];\n                for (seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n                    currentSeries = series[seriesIx];\n                    sortedPoints = chart.sortPoints(seriesPoints[seriesIx]);\n                    pointCount = sortedPoints.length;\n                    linePoints = [];\n                    for (pointIx = 0; pointIx < pointCount; pointIx++) {\n                        point = sortedPoints[pointIx];\n                        if (point) {\n                            linePoints.push(point);\n                        } else if (chart.seriesMissingValues(currentSeries) !== INTERPOLATE) {\n                            if (linePoints.length > 1) {\n                                lastSegment = chart.createSegment(linePoints, currentSeries, seriesIx, lastSegment);\n                                this._addSegment(lastSegment);\n                            }\n                            linePoints = [];\n                        }\n                    }\n                    if (linePoints.length > 1) {\n                        lastSegment = chart.createSegment(linePoints, currentSeries, seriesIx, lastSegment);\n                        this._addSegment(lastSegment);\n                    }\n                }\n                this.children.unshift.apply(this.children, this._segments);\n            },\n            _addSegment: function (segment) {\n                this._segments.push(segment);\n                segment.parent = this;\n            },\n            sortPoints: function (points) {\n                return points;\n            },\n            seriesMissingValues: function (series) {\n                var missingValues = series.missingValues, assumeZero = !missingValues && this.options.isStacked;\n                return assumeZero ? ZERO : missingValues || INTERPOLATE;\n            },\n            getNearestPoint: function (x, y, seriesIx) {\n                var target = new Point2D(x, y);\n                var allPoints = this.seriesPoints[seriesIx];\n                var nearestPointDistance = MAX_VALUE;\n                var nearestPoint;\n                for (var i = 0; i < allPoints.length; i++) {\n                    var point = allPoints[i];\n                    if (point && defined(point.value) && point.value !== null && point.visible !== false) {\n                        var pointBox = point.box;\n                        var pointDistance = pointBox.center().distanceTo(target);\n                        if (pointDistance < nearestPointDistance) {\n                            nearestPoint = point;\n                            nearestPointDistance = pointDistance;\n                        }\n                    }\n                }\n                return nearestPoint;\n            }\n        };\n        var ClipAnimationMixin = {\n            createAnimation: function () {\n                var root = this.getRoot();\n                if (root && (root.options || {}).transitions !== false) {\n                    var box = root.box;\n                    var clipPath = draw.Path.fromRect(box.toRect());\n                    this.visual.clip(clipPath);\n                    this.animation = new ClipAnimation(clipPath, { box: box });\n                    if (anyHasZIndex(this.options.series)) {\n                        this._setChildrenAnimation(clipPath);\n                    }\n                }\n            },\n            _setChildrenAnimation: function (clipPath) {\n                var points = this.animationPoints();\n                var point;\n                for (var idx = 0; idx < points.length; idx++) {\n                    point = points[idx];\n                    if (point && point.visual && defined(point.visual.options.zIndex)) {\n                        point.visual.clip(clipPath);\n                    }\n                }\n            }\n        };\n        var LineChart = CategoricalChart.extend({\n            render: function () {\n                var chart = this;\n                CategoricalChart.fn.render.apply(chart);\n                chart.updateStackRange();\n                chart.renderSegments();\n            },\n            pointType: function () {\n                return LinePoint;\n            },\n            createPoint: function (data, fields) {\n                var chart = this;\n                var categoryIx = fields.categoryIx;\n                var category = fields.category;\n                var series = fields.series;\n                var seriesIx = fields.seriesIx;\n                var value = data.valueFields.value;\n                var missingValues = chart.seriesMissingValues(series);\n                var point;\n                var pointOptions;\n                if (!defined(value) || value === null) {\n                    if (missingValues === ZERO) {\n                        value = 0;\n                    } else {\n                        return null;\n                    }\n                }\n                pointOptions = this.pointOptions(series, seriesIx);\n                pointOptions = chart.evalPointOptions(pointOptions, value, category, categoryIx, series, seriesIx);\n                var color = data.fields.color || series.color;\n                if (kendo.isFunction(series.color)) {\n                    color = pointOptions.color;\n                }\n                point = new LinePoint(value, pointOptions);\n                point.color = color;\n                chart.append(point);\n                return point;\n            },\n            plotRange: function (point) {\n                var plotValue = this.plotValue(point);\n                if (this.options.isStacked) {\n                    var categoryIx = point.categoryIx;\n                    var categoryPts = this.categoryPoints[categoryIx];\n                    for (var i = 0; i < categoryPts.length; i++) {\n                        var other = categoryPts[i];\n                        if (point === other) {\n                            break;\n                        }\n                        plotValue += this.plotValue(other);\n                    }\n                }\n                return [\n                    plotValue,\n                    plotValue\n                ];\n            },\n            createSegment: function (linePoints, currentSeries, seriesIx) {\n                var pointType, style = currentSeries.style;\n                if (style === STEP) {\n                    pointType = StepLineSegment;\n                } else if (style === SMOOTH) {\n                    pointType = SplineSegment;\n                } else {\n                    pointType = LineSegment;\n                }\n                return new pointType(linePoints, currentSeries, seriesIx);\n            },\n            animationPoints: function () {\n                var points = this.points;\n                var result = [];\n                for (var idx = 0; idx < points.length; idx++) {\n                    result.push((points[idx] || {}).marker);\n                }\n                return result.concat(this._segments);\n            }\n        });\n        deepExtend(LineChart.fn, LineChartMixin, ClipAnimationMixin);\n        var ClipAnimation = draw.Animation.extend({\n            options: { duration: INITIAL_ANIMATION_DURATION },\n            setup: function () {\n                this._setEnd(this.options.box.x1);\n            },\n            step: function (pos) {\n                var box = this.options.box;\n                this._setEnd(interpolate(box.x1, box.x2, pos));\n            },\n            _setEnd: function (x) {\n                var element = this.element;\n                var segments = element.segments;\n                var topRight = segments[1].anchor();\n                var bottomRight = segments[2].anchor();\n                element.suspend();\n                topRight.setX(x);\n                element.resume();\n                bottomRight.setX(x);\n            }\n        });\n        draw.AnimationFactory.current.register(CLIP, ClipAnimation);\n        var StepLineSegment = LineSegment.extend({\n            points: function (visualPoints) {\n                var segment = this, points;\n                points = segment.calculateStepPoints(segment.linePoints);\n                if (visualPoints && visualPoints.length) {\n                    points = points.concat(segment.calculateStepPoints(visualPoints).reverse());\n                }\n                return points;\n            },\n            calculateStepPoints: function (points) {\n                var segment = this, chart = segment.parent, plotArea = chart.plotArea, categoryAxis = plotArea.seriesCategoryAxis(segment.series), isInterpolate = chart.seriesMissingValues(segment.series) === INTERPOLATE, length = points.length, reverse = categoryAxis.options.reverse, vertical = categoryAxis.options.vertical, dir = reverse ? 2 : 1, revDir = reverse ? 1 : 2, prevPoint, point, i, prevMarkerBoxCenter, markerBoxCenter, result = [];\n                for (i = 1; i < length; i++) {\n                    prevPoint = points[i - 1];\n                    point = points[i];\n                    prevMarkerBoxCenter = prevPoint.markerBox().center();\n                    markerBoxCenter = point.markerBox().center();\n                    if (categoryAxis.options.justified) {\n                        result.push(new geom.Point(prevMarkerBoxCenter.x, prevMarkerBoxCenter.y));\n                        if (vertical) {\n                            result.push(new geom.Point(prevMarkerBoxCenter.x, markerBoxCenter.y));\n                        } else {\n                            result.push(new geom.Point(markerBoxCenter.x, prevMarkerBoxCenter.y));\n                        }\n                        result.push(new geom.Point(markerBoxCenter.x, markerBoxCenter.y));\n                    } else {\n                        if (vertical) {\n                            result.push(new geom.Point(prevMarkerBoxCenter.x, prevPoint.box[Y + dir]));\n                            result.push(new geom.Point(prevMarkerBoxCenter.x, prevPoint.box[Y + revDir]));\n                            if (isInterpolate) {\n                                result.push(new geom.Point(prevMarkerBoxCenter.x, point.box[Y + dir]));\n                            }\n                            result.push(new geom.Point(markerBoxCenter.x, point.box[Y + dir]));\n                            result.push(new geom.Point(markerBoxCenter.x, point.box[Y + revDir]));\n                        } else {\n                            result.push(new geom.Point(prevPoint.box[X + dir], prevMarkerBoxCenter.y));\n                            result.push(new geom.Point(prevPoint.box[X + revDir], prevMarkerBoxCenter.y));\n                            if (isInterpolate) {\n                                result.push(new geom.Point(point.box[X + dir], prevMarkerBoxCenter.y));\n                            }\n                            result.push(new geom.Point(point.box[X + dir], markerBoxCenter.y));\n                            result.push(new geom.Point(point.box[X + revDir], markerBoxCenter.y));\n                        }\n                    }\n                }\n                return result || [];\n            }\n        });\n        var SplineSegment = LineSegment.extend({\n            createVisual: function () {\n                var series = this.series;\n                var defaults = series._defaults;\n                var color = series.color;\n                if (isFn(color) && defaults) {\n                    color = defaults.color;\n                }\n                var curveProcessor = new CurveProcessor(this.options.closed);\n                var segments = curveProcessor.process(this.points());\n                var curve = new draw.Path({\n                    stroke: {\n                        color: color,\n                        width: series.width,\n                        opacity: series.opacity,\n                        dashType: series.dashType\n                    },\n                    zIndex: series.zIndex\n                });\n                curve.segments.push.apply(curve.segments, segments);\n                this.visual = curve;\n            }\n        });\n        var AreaSegmentMixin = {\n            points: function () {\n                var segment = this, chart = segment.parent, plotArea = chart.plotArea, invertAxes = chart.options.invertAxes, valueAxis = chart.seriesValueAxis(segment.series), valueAxisLineBox = valueAxis.lineBox(), categoryAxis = plotArea.seriesCategoryAxis(segment.series), categoryAxisLineBox = categoryAxis.lineBox(), end = invertAxes ? categoryAxisLineBox.x1 : categoryAxisLineBox.y1, stackPoints = segment.stackPoints, points = segment._linePoints(stackPoints), pos = invertAxes ? X : Y, firstPoint, lastPoint;\n                end = limitValue(end, valueAxisLineBox[pos + 1], valueAxisLineBox[pos + 2]);\n                if (!segment.stackPoints && points.length > 1) {\n                    firstPoint = points[0];\n                    lastPoint = last(points);\n                    if (invertAxes) {\n                        points.unshift(new geom.Point(end, firstPoint.y));\n                        points.push(new geom.Point(end, lastPoint.y));\n                    } else {\n                        points.unshift(new geom.Point(firstPoint.x, end));\n                        points.push(new geom.Point(lastPoint.x, end));\n                    }\n                }\n                return points;\n            },\n            createVisual: function () {\n                var series = this.series;\n                var defaults = series._defaults;\n                var color = series.color;\n                if (isFn(color) && defaults) {\n                    color = defaults.color;\n                }\n                this.visual = new draw.Group({ zIndex: series.zIndex });\n                this.createArea(color);\n                this.createLine(color);\n            },\n            createLine: function (color) {\n                var series = this.series;\n                var lineOptions = deepExtend({\n                    color: color,\n                    opacity: series.opacity\n                }, series.line);\n                if (lineOptions.visible !== false && lineOptions.width > 0) {\n                    var line = draw.Path.fromPoints(this._linePoints(), {\n                        stroke: {\n                            color: lineOptions.color,\n                            width: lineOptions.width,\n                            opacity: lineOptions.opacity,\n                            dashType: lineOptions.dashType,\n                            lineCap: 'butt'\n                        }\n                    });\n                    this.visual.append(line);\n                }\n            },\n            createArea: function (color) {\n                var series = this.series;\n                var area = draw.Path.fromPoints(this.points(), {\n                    fill: {\n                        color: color,\n                        opacity: series.opacity\n                    },\n                    stroke: null\n                });\n                this.visual.append(area);\n            }\n        };\n        var AreaSegment = LineSegment.extend({\n            init: function (linePoints, stackPoints, currentSeries, seriesIx) {\n                var segment = this;\n                segment.stackPoints = stackPoints;\n                LineSegment.fn.init.call(segment, linePoints, currentSeries, seriesIx);\n            },\n            _linePoints: LineSegment.fn.points\n        });\n        deepExtend(AreaSegment.fn, AreaSegmentMixin);\n        var AreaChart = LineChart.extend({\n            createSegment: function (linePoints, currentSeries, seriesIx, prevSegment) {\n                var chart = this, options = chart.options, isStacked = options.isStacked, stackPoints, pointType, style = (currentSeries.line || {}).style;\n                if (isStacked && seriesIx > 0 && prevSegment) {\n                    var missingValues = this.seriesMissingValues(currentSeries);\n                    if (missingValues != 'gap') {\n                        stackPoints = prevSegment.linePoints;\n                    } else {\n                        stackPoints = this._gapStackPoints(linePoints, seriesIx, style);\n                    }\n                    if (style !== STEP) {\n                        stackPoints = stackPoints.slice(0).reverse();\n                    }\n                }\n                if (style === SMOOTH) {\n                    return new SplineAreaSegment(linePoints, prevSegment, isStacked, currentSeries, seriesIx);\n                }\n                if (style === STEP) {\n                    pointType = StepAreaSegment;\n                } else {\n                    pointType = AreaSegment;\n                }\n                return new pointType(linePoints, stackPoints, currentSeries, seriesIx);\n            },\n            reflow: function (targetBox) {\n                LineChart.fn.reflow.call(this, targetBox);\n                var stackPoints = this._stackPoints;\n                if (stackPoints) {\n                    var stackPoint, pointSlot;\n                    for (var idx = 0; idx < stackPoints.length; idx++) {\n                        stackPoint = stackPoints[idx];\n                        pointSlot = this.categoryAxis.getSlot(stackPoint.categoryIx);\n                        stackPoint.reflow(pointSlot);\n                    }\n                }\n            },\n            _gapStackPoints: function (linePoints, seriesIx, style) {\n                var seriesPoints = this.seriesPoints;\n                var startIdx = linePoints[0].categoryIx;\n                var endIdx = startIdx + linePoints.length;\n                var stackPoints = [];\n                var currentSeriesIx;\n                var point, gapStackPoint;\n                this._stackPoints = this._stackPoints || [];\n                for (var idx = startIdx; idx < endIdx; idx++) {\n                    currentSeriesIx = seriesIx;\n                    do {\n                        currentSeriesIx--;\n                        point = seriesPoints[currentSeriesIx][idx];\n                    } while (currentSeriesIx > 0 && !point);\n                    if (point) {\n                        if (style !== STEP && idx > startIdx && !seriesPoints[currentSeriesIx][idx - 1]) {\n                            stackPoints.push(this._previousSegmentPoint(idx, idx - 1, currentSeriesIx));\n                        }\n                        stackPoints.push(point);\n                        if (style !== STEP && idx + 1 < endIdx && !seriesPoints[currentSeriesIx][idx + 1]) {\n                            stackPoints.push(this._previousSegmentPoint(idx, idx + 1, currentSeriesIx));\n                        }\n                    } else {\n                        gapStackPoint = this._createGapStackPoint(idx);\n                        this._stackPoints.push(gapStackPoint);\n                        stackPoints.push(gapStackPoint);\n                    }\n                }\n                return stackPoints;\n            },\n            _previousSegmentPoint: function (categoryIx, segmentIx, seriesIdx) {\n                var seriesPoints = this.seriesPoints;\n                var point;\n                while (seriesIdx > 0 && !point) {\n                    seriesIdx--;\n                    point = seriesPoints[seriesIdx][segmentIx];\n                }\n                if (!point) {\n                    point = this._createGapStackPoint(categoryIx);\n                    this._stackPoints.push(point);\n                } else {\n                    point = seriesPoints[seriesIdx][categoryIx];\n                }\n                return point;\n            },\n            _createGapStackPoint: function (categoryIx) {\n                var options = this.pointOptions({}, 0);\n                var point = new LinePoint(0, options);\n                point.categoryIx = categoryIx;\n                point.series = {};\n                return point;\n            },\n            seriesMissingValues: function (series) {\n                return series.missingValues || ZERO;\n            }\n        });\n        var SplineAreaSegment = AreaSegment.extend({\n            init: function (linePoints, prevSegment, isStacked, currentSeries, seriesIx) {\n                var segment = this;\n                segment.prevSegment = prevSegment;\n                segment.isStacked = isStacked;\n                LineSegment.fn.init.call(segment, linePoints, currentSeries, seriesIx);\n            },\n            strokeSegments: function () {\n                var segments = this._strokeSegments;\n                if (!segments) {\n                    var curveProcessor = new CurveProcessor(this.options.closed);\n                    var linePoints = LineSegment.fn.points.call(this);\n                    segments = this._strokeSegments = curveProcessor.process(linePoints);\n                }\n                return segments;\n            },\n            createVisual: function () {\n                var series = this.series;\n                var defaults = series._defaults;\n                var color = series.color;\n                if (isFn(color) && defaults) {\n                    color = defaults.color;\n                }\n                this.visual = new draw.Group({ zIndex: series.zIndex });\n                this.createFill({\n                    fill: {\n                        color: color,\n                        opacity: series.opacity\n                    },\n                    stroke: null\n                });\n                this.createStroke({\n                    stroke: deepExtend({\n                        color: color,\n                        opacity: series.opacity,\n                        lineCap: 'butt'\n                    }, series.line)\n                });\n            },\n            createFill: function (style) {\n                var strokeSegments = this.strokeSegments();\n                var fillSegments = strokeSegments.slice(0);\n                var prevSegment = this.prevSegment;\n                if (this.isStacked && prevSegment) {\n                    var prevStrokeSegments = prevSegment.strokeSegments();\n                    var prevAnchor = last(prevStrokeSegments).anchor();\n                    fillSegments.push(new draw.Segment(prevAnchor, prevAnchor, last(strokeSegments).anchor()));\n                    var stackSegments = $.map(prevStrokeSegments, function (segment) {\n                        return new draw.Segment(segment.anchor(), segment.controlOut(), segment.controlIn());\n                    }).reverse();\n                    append(fillSegments, stackSegments);\n                    var firstAnchor = fillSegments[0].anchor();\n                    fillSegments.push(new draw.Segment(firstAnchor, firstAnchor, last(stackSegments).anchor()));\n                }\n                var fill = new draw.Path(style);\n                fill.segments.push.apply(fill.segments, fillSegments);\n                this.closeFill(fill);\n                this.visual.append(fill);\n            },\n            closeFill: function (fillPath) {\n                var segment = this, chart = segment.parent, prevSegment = segment.prevSegment, plotArea = chart.plotArea, invertAxes = chart.options.invertAxes, valueAxis = chart.seriesValueAxis(segment.series), valueAxisLineBox = valueAxis.lineBox(), categoryAxis = plotArea.seriesCategoryAxis(segment.series), categoryAxisLineBox = categoryAxis.lineBox(), end = invertAxes ? categoryAxisLineBox.x1 : categoryAxisLineBox.y1, pos = invertAxes ? X : Y, segments = segment.strokeSegments(), firstPoint = segments[0].anchor(), lastPoint = last(segments).anchor();\n                end = limitValue(end, valueAxisLineBox[pos + 1], valueAxisLineBox[pos + 2]);\n                if (!(chart.options.isStacked && prevSegment) && segments.length > 1) {\n                    if (invertAxes) {\n                        fillPath.lineTo(end, lastPoint.y).lineTo(end, firstPoint.y);\n                    } else {\n                        fillPath.lineTo(lastPoint.x, end).lineTo(firstPoint.x, end);\n                    }\n                }\n            },\n            createStroke: function (style) {\n                if (style.stroke.width > 0) {\n                    var stroke = new draw.Path(style);\n                    stroke.segments.push.apply(stroke.segments, this.strokeSegments());\n                    this.visual.append(stroke);\n                }\n            }\n        });\n        var StepAreaSegment = StepLineSegment.extend({\n            init: function (linePoints, stackPoints, currentSeries, seriesIx) {\n                var segment = this;\n                segment.stackPoints = stackPoints;\n                StepLineSegment.fn.init.call(segment, linePoints, currentSeries, seriesIx);\n            },\n            _linePoints: StepLineSegment.fn.points\n        });\n        deepExtend(StepAreaSegment.fn, AreaSegmentMixin);\n        var ScatterChart = ChartElement.extend({\n            init: function (plotArea, options) {\n                var chart = this;\n                ChartElement.fn.init.call(chart, options);\n                chart.plotArea = plotArea;\n                chart.xAxisRanges = {};\n                chart.yAxisRanges = {};\n                chart.points = [];\n                chart.seriesPoints = [];\n                chart.seriesOptions = [];\n                chart._evalSeries = [];\n                chart.render();\n            },\n            options: {\n                series: [],\n                tooltip: { format: '{0}, {1}' },\n                labels: { format: '{0}, {1}' },\n                clip: true\n            },\n            render: function () {\n                var chart = this;\n                chart.traverseDataPoints(proxy(chart.addValue, chart));\n            },\n            addErrorBar: function (point, field, fields) {\n                var errorRange, chart = this, value = point.value[field], valueErrorField = field + 'Value', lowField = field + 'ErrorLow', highField = field + 'ErrorHigh', seriesIx = fields.seriesIx, series = fields.series, errorBars = point.options.errorBars, lowValue = fields[lowField], highValue = fields[highField];\n                if (isNumber(value)) {\n                    if (isNumber(lowValue) && isNumber(highValue)) {\n                        errorRange = {\n                            low: lowValue,\n                            high: highValue\n                        };\n                    }\n                    if (errorBars && defined(errorBars[valueErrorField])) {\n                        chart.seriesErrorRanges = chart.seriesErrorRanges || {\n                            x: [],\n                            y: []\n                        };\n                        chart.seriesErrorRanges[field][seriesIx] = chart.seriesErrorRanges[field][seriesIx] || new ErrorRangeCalculator(errorBars[valueErrorField], series, field);\n                        errorRange = chart.seriesErrorRanges[field][seriesIx].getErrorRange(value, errorBars[valueErrorField]);\n                    }\n                    if (errorRange) {\n                        chart.addPointErrorBar(errorRange, point, field);\n                    }\n                }\n            },\n            addPointErrorBar: function (errorRange, point, field) {\n                var chart = this, low = errorRange.low, high = errorRange.high, series = point.series, isVertical = field === Y, options = point.options.errorBars, item = {}, errorBar;\n                point[field + 'Low'] = low;\n                point[field + 'High'] = high;\n                point.errorBars = point.errorBars || [];\n                errorBar = new ScatterErrorBar(low, high, isVertical, chart, series, options);\n                point.errorBars.push(errorBar);\n                point.append(errorBar);\n                item[field] = low;\n                chart.updateRange(item, series);\n                item[field] = high;\n                chart.updateRange(item, series);\n            },\n            addValue: function (value, fields) {\n                var chart = this, point, x = value.x, y = value.y, seriesIx = fields.seriesIx, series = this.options.series[seriesIx], missingValues = this.seriesMissingValues(series), seriesPoints = chart.seriesPoints[seriesIx];\n                if (!(hasValue(x) && hasValue(y))) {\n                    value = this.createMissingValue(value, missingValues);\n                }\n                if (value) {\n                    point = chart.createPoint(value, fields);\n                    if (point) {\n                        extend(point, fields);\n                        chart.addErrorBar(point, X, fields);\n                        chart.addErrorBar(point, Y, fields);\n                    }\n                    chart.updateRange(value, fields.series);\n                }\n                chart.points.push(point);\n                seriesPoints.push(point);\n            },\n            seriesMissingValues: function (series) {\n                return series.missingValues;\n            },\n            createMissingValue: noop,\n            updateRange: function (value, series) {\n                var chart = this, x = value.x, y = value.y, xAxisName = series.xAxis, yAxisName = series.yAxis, xAxisRange = chart.xAxisRanges[xAxisName], yAxisRange = chart.yAxisRanges[yAxisName];\n                if (hasValue(x)) {\n                    xAxisRange = chart.xAxisRanges[xAxisName] = xAxisRange || {\n                        min: MAX_VALUE,\n                        max: MIN_VALUE\n                    };\n                    if (typeof x === STRING) {\n                        x = toDate(x);\n                    }\n                    xAxisRange.min = math.min(xAxisRange.min, x);\n                    xAxisRange.max = math.max(xAxisRange.max, x);\n                }\n                if (hasValue(y)) {\n                    yAxisRange = chart.yAxisRanges[yAxisName] = yAxisRange || {\n                        min: MAX_VALUE,\n                        max: MIN_VALUE\n                    };\n                    if (typeof y === STRING) {\n                        y = toDate(y);\n                    }\n                    yAxisRange.min = math.min(yAxisRange.min, y);\n                    yAxisRange.max = math.max(yAxisRange.max, y);\n                }\n            },\n            evalPointOptions: function (options, value, fields) {\n                var series = fields.series;\n                var seriesIx = fields.seriesIx;\n                var state = {\n                    defaults: series._defaults,\n                    excluded: [\n                        'data',\n                        'tooltip',\n                        'tempate',\n                        'visual',\n                        'toggle',\n                        '_outOfRangeMinPoint',\n                        '_outOfRangeMaxPoint'\n                    ]\n                };\n                var doEval = this._evalSeries[seriesIx];\n                if (!defined(doEval)) {\n                    this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n                }\n                if (doEval) {\n                    options = deepExtend({}, options);\n                    evalOptions(options, {\n                        value: value,\n                        series: series,\n                        dataItem: fields.dataItem\n                    }, state);\n                }\n                return options;\n            },\n            pointType: function () {\n                return LinePoint;\n            },\n            pointOptions: function (series, seriesIx) {\n                var options = this.seriesOptions[seriesIx];\n                if (!options) {\n                    var defaults = this.pointType().fn.defaults;\n                    this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n                        markers: { opacity: series.opacity },\n                        tooltip: { format: this.options.tooltip.format },\n                        labels: { format: this.options.labels.format }\n                    }, series);\n                }\n                return options;\n            },\n            createPoint: function (value, fields) {\n                var chart = this, series = fields.series, point;\n                var pointOptions = this.pointOptions(series, fields.seriesIx);\n                var color = fields.color || series.color;\n                pointOptions = chart.evalPointOptions(pointOptions, value, fields);\n                if (kendo.isFunction(series.color)) {\n                    color = pointOptions.color;\n                }\n                point = new LinePoint(value, pointOptions);\n                point.color = color;\n                chart.append(point);\n                return point;\n            },\n            seriesAxes: function (series) {\n                var plotArea = this.plotArea, xAxisName = series.xAxis, xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX, yAxisName = series.yAxis, yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;\n                if (!xAxis) {\n                    throw new Error('Unable to locate X axis with name ' + xAxisName);\n                }\n                if (!yAxis) {\n                    throw new Error('Unable to locate Y axis with name ' + yAxisName);\n                }\n                return {\n                    x: xAxis,\n                    y: yAxis\n                };\n            },\n            reflow: function (targetBox) {\n                var chart = this, chartPoints = chart.points, pointIx = 0, point, seriesAxes, limit = !chart.options.clip;\n                chart.traverseDataPoints(function (value, fields) {\n                    point = chartPoints[pointIx++];\n                    seriesAxes = chart.seriesAxes(fields.series);\n                    var slotX = seriesAxes.x.getSlot(value.x, value.x, limit), slotY = seriesAxes.y.getSlot(value.y, value.y, limit), pointSlot;\n                    if (point) {\n                        if (slotX && slotY) {\n                            pointSlot = chart.pointSlot(slotX, slotY);\n                            point.reflow(pointSlot);\n                        } else {\n                            point.visible = false;\n                        }\n                    }\n                });\n                chart.box = targetBox;\n            },\n            pointSlot: function (slotX, slotY) {\n                return new Box2D(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n            },\n            traverseDataPoints: function (callback) {\n                var chart = this, options = chart.options, series = options.series, seriesPoints = chart.seriesPoints, pointIx, seriesIx, currentSeries, currentSeriesPoints, pointData, value, fields;\n                for (seriesIx = 0; seriesIx < series.length; seriesIx++) {\n                    currentSeries = series[seriesIx];\n                    currentSeriesPoints = seriesPoints[seriesIx];\n                    if (!currentSeriesPoints) {\n                        seriesPoints[seriesIx] = [];\n                    }\n                    for (pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n                        pointData = this._bindPoint(currentSeries, seriesIx, pointIx);\n                        value = pointData.valueFields;\n                        fields = pointData.fields;\n                        callback(value, deepExtend({\n                            pointIx: pointIx,\n                            series: currentSeries,\n                            seriesIx: seriesIx,\n                            dataItem: currentSeries.data[pointIx],\n                            owner: chart\n                        }, fields));\n                    }\n                }\n            },\n            _bindPoint: CategoricalChart.fn._bindPoint,\n            formatPointValue: function (point, format) {\n                var value = point.value;\n                return autoFormat(format, value.x, value.y);\n            },\n            animationPoints: function () {\n                var points = this.points;\n                var result = [];\n                for (var idx = 0; idx < points.length; idx++) {\n                    result.push((points[idx] || {}).marker);\n                }\n                return result;\n            }\n        });\n        deepExtend(ScatterChart.fn, ClipAnimationMixin);\n        var ScatterLineChart = ScatterChart.extend({\n            render: function () {\n                var chart = this;\n                ScatterChart.fn.render.call(chart);\n                chart.renderSegments();\n            },\n            createSegment: function (linePoints, currentSeries, seriesIx) {\n                var pointType, style = currentSeries.style;\n                if (style === SMOOTH) {\n                    pointType = SplineSegment;\n                } else {\n                    pointType = LineSegment;\n                }\n                return new pointType(linePoints, currentSeries, seriesIx);\n            },\n            animationPoints: function () {\n                var points = ScatterChart.fn.animationPoints.call(this);\n                return points.concat(this._segments);\n            },\n            createMissingValue: function (value, missingValues) {\n                if (missingValues === ZERO) {\n                    var missingValue = {\n                        x: value.x,\n                        y: value.y\n                    };\n                    if (!hasValue(missingValue.x)) {\n                        missingValue.x = 0;\n                    }\n                    if (!hasValue(missingValue.y)) {\n                        missingValue.y = 0;\n                    }\n                    return missingValue;\n                }\n            }\n        });\n        deepExtend(ScatterLineChart.fn, LineChartMixin);\n        var BubbleChart = ScatterChart.extend({\n            init: function (plotArea, options) {\n                this._maxSize = MIN_VALUE;\n                ScatterChart.fn.init.call(this, plotArea, options);\n            },\n            options: {\n                tooltip: { format: '{3}' },\n                labels: { format: '{3}' }\n            },\n            addValue: function (value, fields) {\n                if (value.size !== null && (value.size > 0 || value.size < 0 && fields.series.negativeValues.visible)) {\n                    this._maxSize = math.max(this._maxSize, math.abs(value.size));\n                    ScatterChart.fn.addValue.call(this, value, fields);\n                } else {\n                    this.points.push(null);\n                    this.seriesPoints[fields.seriesIx].push(null);\n                }\n            },\n            reflow: function (box) {\n                var chart = this;\n                chart.updateBubblesSize(box);\n                ScatterChart.fn.reflow.call(chart, box);\n            },\n            pointType: function () {\n                return Bubble;\n            },\n            createPoint: function (value, fields) {\n                var chart = this, series = fields.series, pointsCount = series.data.length, delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount), animationOptions = {\n                        delay: delay,\n                        duration: INITIAL_ANIMATION_DURATION - delay,\n                        type: BUBBLE\n                    }, point, pointOptions;\n                var color = fields.color || series.color;\n                if (value.size < 0 && series.negativeValues.visible) {\n                    color = valueOrDefault(series.negativeValues.color, color);\n                }\n                pointOptions = deepExtend({\n                    labels: {\n                        animation: {\n                            delay: delay,\n                            duration: INITIAL_ANIMATION_DURATION - delay\n                        }\n                    }\n                }, this.pointOptions(series, fields.seriesIx), {\n                    markers: {\n                        type: CIRCLE,\n                        border: series.border,\n                        opacity: series.opacity,\n                        animation: animationOptions\n                    }\n                });\n                pointOptions = chart.evalPointOptions(pointOptions, value, fields);\n                if (kendo.isFunction(series.color)) {\n                    color = pointOptions.color;\n                }\n                pointOptions.markers.background = color;\n                point = new Bubble(value, pointOptions);\n                point.color = color;\n                chart.append(point);\n                return point;\n            },\n            updateBubblesSize: function (box) {\n                var chart = this, options = chart.options, series = options.series, boxSize = math.min(box.width(), box.height()), seriesIx, pointIx;\n                for (seriesIx = 0; seriesIx < series.length; seriesIx++) {\n                    var currentSeries = series[seriesIx], seriesPoints = chart.seriesPoints[seriesIx], minSize = currentSeries.minSize || math.max(boxSize * 0.02, 10), maxSize = currentSeries.maxSize || boxSize * 0.2, minR = minSize / 2, maxR = maxSize / 2, minArea = math.PI * minR * minR, maxArea = math.PI * maxR * maxR, areaRange = maxArea - minArea, areaRatio = areaRange / chart._maxSize;\n                    for (pointIx = 0; pointIx < seriesPoints.length; pointIx++) {\n                        var point = seriesPoints[pointIx];\n                        if (point) {\n                            var area = math.abs(point.value.size) * areaRatio, r = math.sqrt((minArea + area) / math.PI), baseZIndex = valueOrDefault(point.options.zIndex, 0), zIndex = baseZIndex + (1 - r / maxR);\n                            deepExtend(point.options, {\n                                zIndex: zIndex,\n                                markers: {\n                                    size: r * 2,\n                                    zIndex: zIndex\n                                },\n                                labels: { zIndex: zIndex + 1 }\n                            });\n                        }\n                    }\n                }\n            },\n            formatPointValue: function (point, format) {\n                var value = point.value;\n                return autoFormat(format, value.x, value.y, value.size, point.category);\n            },\n            createAnimation: noop,\n            createVisual: noop\n        });\n        var Candlestick = ChartElement.extend({\n            init: function (value, options) {\n                ChartElement.fn.init.call(this, options);\n                this.value = value;\n            },\n            options: {\n                border: { _brightness: 0.8 },\n                line: { width: 2 },\n                overlay: { gradient: GLASS },\n                tooltip: { format: '<table style=\\'text-align: left;\\'>' + '<th colspan=\\'2\\'>{4:d}</th>' + '<tr><td>Open:</td><td>{0:C}</td></tr>' + '<tr><td>High:</td><td>{1:C}</td></tr>' + '<tr><td>Low:</td><td>{2:C}</td></tr>' + '<tr><td>Close:</td><td>{3:C}</td></tr>' + '</table>' },\n                highlight: {\n                    opacity: 1,\n                    border: {\n                        width: 1,\n                        opacity: 1\n                    },\n                    line: {\n                        width: 1,\n                        opacity: 1\n                    }\n                },\n                notes: {\n                    visible: true,\n                    label: {}\n                }\n            },\n            reflow: function (box) {\n                var point = this, options = point.options, chart = point.owner, value = point.value, valueAxis = chart.seriesValueAxis(options), points = [], mid, ocSlot, lhSlot;\n                ocSlot = valueAxis.getSlot(value.open, value.close);\n                lhSlot = valueAxis.getSlot(value.low, value.high);\n                ocSlot.x1 = lhSlot.x1 = box.x1;\n                ocSlot.x2 = lhSlot.x2 = box.x2;\n                point.realBody = ocSlot;\n                mid = lhSlot.center().x;\n                points.push([\n                    [\n                        mid,\n                        lhSlot.y1\n                    ],\n                    [\n                        mid,\n                        ocSlot.y1\n                    ]\n                ]);\n                points.push([\n                    [\n                        mid,\n                        ocSlot.y2\n                    ],\n                    [\n                        mid,\n                        lhSlot.y2\n                    ]\n                ]);\n                point.lines = points;\n                point.box = lhSlot.clone().wrap(ocSlot);\n                if (!point._rendered) {\n                    point._rendered = true;\n                    point.createNote();\n                }\n                point.reflowNote();\n            },\n            reflowNote: function () {\n                var point = this;\n                if (point.note) {\n                    point.note.reflow(point.box);\n                }\n            },\n            createVisual: function () {\n                ChartElement.fn.createVisual.call(this);\n                this._mainVisual = this.mainVisual(this.options);\n                this.visual.append(this._mainVisual);\n                this.createOverlay();\n            },\n            mainVisual: function (options) {\n                var group = new draw.Group();\n                this.createBody(group, options);\n                this.createLines(group, options);\n                return group;\n            },\n            createBody: function (container, options) {\n                var body = draw.Path.fromRect(this.realBody.toRect(), {\n                    fill: {\n                        color: this.color,\n                        opacity: options.opacity\n                    },\n                    stroke: null\n                });\n                if (options.border.width > 0) {\n                    body.options.set('stroke', {\n                        color: this.getBorderColor(),\n                        width: options.border.width,\n                        dashType: options.border.dashType,\n                        opacity: valueOrDefault(options.border.opacity, options.opacity)\n                    });\n                }\n                alignPathToPixel(body);\n                container.append(body);\n                if (hasGradientOverlay(options)) {\n                    container.append(this.createGradientOverlay(body, { baseColor: this.color }, deepExtend({}, options.overlay)));\n                }\n            },\n            createLines: function (container, options) {\n                this.drawLines(container, options, this.lines, options.line);\n            },\n            drawLines: function (container, options, lines, lineOptions) {\n                if (!lines) {\n                    return;\n                }\n                var lineStyle = {\n                    stroke: {\n                        color: lineOptions.color || this.color,\n                        opacity: valueOrDefault(lineOptions.opacity, options.opacity),\n                        width: lineOptions.width,\n                        dashType: lineOptions.dashType,\n                        lineCap: 'butt'\n                    }\n                };\n                for (var i = 0; i < lines.length; i++) {\n                    var line = draw.Path.fromPoints(lines[i], lineStyle);\n                    alignPathToPixel(line);\n                    container.append(line);\n                }\n            },\n            getBorderColor: function () {\n                var point = this, options = point.options, border = options.border, borderColor = border.color;\n                if (!defined(borderColor)) {\n                    borderColor = new Color(point.color).brightness(border._brightness).toHex();\n                }\n                return borderColor;\n            },\n            createOverlay: function () {\n                var overlay = draw.Path.fromRect(this.box.toRect(), {\n                    fill: {\n                        color: WHITE,\n                        opacity: 0\n                    },\n                    stroke: null\n                });\n                this.visual.append(overlay);\n            },\n            createHighlight: function () {\n                var highlight = this.options.highlight;\n                var normalColor = this.color;\n                this.color = highlight.color || this.color;\n                var overlay = this.mainVisual(deepExtend({}, this.options, { line: { color: this.getBorderColor() } }, highlight));\n                this.color = normalColor;\n                return overlay;\n            },\n            highlightVisual: function () {\n                return this._mainVisual;\n            },\n            highlightVisualArgs: function () {\n                return {\n                    options: this.options,\n                    rect: this.box.toRect(),\n                    visual: this._mainVisual\n                };\n            },\n            tooltipAnchor: function () {\n                var point = this, box = point.box, clipBox = point.owner.pane.clipBox() || box;\n                return new Point2D(box.x2 + TOOLTIP_OFFSET, math.max(box.y1, clipBox.y1) + TOOLTIP_OFFSET);\n            },\n            formatValue: function (format) {\n                var point = this;\n                return point.owner.formatPointValue(point, format);\n            },\n            overlapsBox: function (box) {\n                return this.box.overlaps(box);\n            }\n        });\n        deepExtend(Candlestick.fn, PointEventsMixin);\n        deepExtend(Candlestick.fn, NoteMixin);\n        var CandlestickChart = CategoricalChart.extend({\n            options: {},\n            reflowCategories: function (categorySlots) {\n                var chart = this, children = chart.children, childrenLength = children.length, i;\n                for (i = 0; i < childrenLength; i++) {\n                    children[i].reflow(categorySlots[i]);\n                }\n            },\n            addValue: function (data, fields) {\n                var chart = this;\n                var categoryIx = fields.categoryIx;\n                var category = fields.category;\n                var series = fields.series;\n                var seriesIx = fields.seriesIx;\n                var options = chart.options;\n                var value = data.valueFields;\n                var children = chart.children;\n                var valueParts = chart.splitValue(value);\n                var hasValue = areNumbers(valueParts);\n                var categoryPoints = chart.categoryPoints[categoryIx];\n                var dataItem = series.data[categoryIx];\n                var point, cluster;\n                if (!categoryPoints) {\n                    chart.categoryPoints[categoryIx] = categoryPoints = [];\n                }\n                if (hasValue) {\n                    point = chart.createPoint(data, fields);\n                }\n                cluster = children[categoryIx];\n                if (!cluster) {\n                    cluster = new ClusterLayout({\n                        vertical: options.invertAxes,\n                        gap: options.gap,\n                        spacing: options.spacing\n                    });\n                    chart.append(cluster);\n                }\n            